name: Deploy Frontend

on:
  push:
    branches: [ "main" ]

permissions:
  id-token: write   # Required for requesting the JWT
  contents: read    # Required for actions/checkout
  packages: write   # Required to push to GHCR

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  CONTAINER_NAME: payload-frontend

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set Lowercase Image Name
        run: |
          echo "IMAGE_NAME=ghcr.io/$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')/payload-tutorials-frontend:latest" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ env.IMAGE_NAME }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to EC2 via SSM
        run: |
          # Define the deployment script explicitly
          # Using a heredoc with EOT to avoid quote escaping issues
          COMMANDS=$(cat <<EOT
          echo 'Pulling new image...'
          echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          docker pull ${{ env.IMAGE_NAME }}
            
          echo 'Stopping old container...'
          docker stop ${{ env.CONTAINER_NAME }} || true
          docker rm ${{ env.CONTAINER_NAME }} || true
            
          echo 'Running new container...'
          # Note: Mapping to port 3001 to avoid conflict with backend on 3000
          docker run -d \
            -p 3001:3000 \
            --name ${{ env.CONTAINER_NAME }} \
            --restart unless-stopped \
            -e NEXT_PUBLIC_BACKEND_URL=http://localhost:3000 \
            ${{ env.IMAGE_NAME }}
          EOT
          )
          
          # Use jq to robustly generate the JSON payload for commands
          # This handles newlines and quotes inside the script correctly
          PARAMS=$(jq -n --arg cmd "$COMMANDS" '{"commands": [$cmd]}')
          
          # Send the command
          # Send the command and capture the Command ID
          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=tag:Deployment,Values=PayloadCMS" \
            --parameters "$PARAMS" \
            --comment "Deploying Frontend via GitHub Actions" \
            --query "Command.CommandId" \
            --output text)

          echo "Command ID: $COMMAND_ID"

          # Wait for the command to complete
          STATUS="Pending"
          while [[ "$STATUS" == "Pending" || "$STATUS" == "InProgress" ]]; do
            sleep 5
            STATUS=$(aws ssm list-command-invocations \
              --command-id "$COMMAND_ID" \
              --details \
              --query "CommandInvocations[0].Status" \
              --output text)
            echo "Status: $STATUS"
          done

          # Get the full output (stdout and stderr)
          echo "Instance Output:"
          aws ssm list-command-invocations \
            --command-id "$COMMAND_ID" \
            --details \
            --query "CommandInvocations[0].CommandPlugins[0].Output" \
            --output text

          if [[ "$STATUS" != "Success" ]]; then
            echo "Deployment failed!"
            exit 1
          fi
